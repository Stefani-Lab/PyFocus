:mod:`PyFocus.auxiliary.tmm_core`
=================================

.. py:module:: PyFocus.auxiliary.tmm_core

.. autoapi-nested-parse::

   For information see the docstring of each function, and also see manual.pdf

   The most two important functions are:

   coh_tmm(...) -- the transfer-matrix-method calculation in the coherent
   case (i.e. thin films)

   inc_tmm(...) -- the transfer-matrix-method calculation in the incoherent
   case (i.e. films tens or hundreds of wavelengths thick, or whose
   thickness is not very uniform.)

   These functions are all imported into the main package (tmm) namespace,
   so you can call them with tmm.coh_tmm(...) etc.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   PyFocus.auxiliary.tmm_core.absorp_analytic_fn



Functions
~~~~~~~~~

.. autoapisummary::

   PyFocus.auxiliary.tmm_core.make_2x2_array
   PyFocus.auxiliary.tmm_core.is_forward_angle
   PyFocus.auxiliary.tmm_core.snell
   PyFocus.auxiliary.tmm_core.list_snell
   PyFocus.auxiliary.tmm_core.interface_r
   PyFocus.auxiliary.tmm_core.interface_t
   PyFocus.auxiliary.tmm_core.R_from_r
   PyFocus.auxiliary.tmm_core.T_from_t
   PyFocus.auxiliary.tmm_core.power_entering_from_r
   PyFocus.auxiliary.tmm_core.interface_R
   PyFocus.auxiliary.tmm_core.interface_T
   PyFocus.auxiliary.tmm_core.coh_tmm
   PyFocus.auxiliary.tmm_core.coh_tmm_reverse
   PyFocus.auxiliary.tmm_core.ellips
   PyFocus.auxiliary.tmm_core.unpolarized_RT
   PyFocus.auxiliary.tmm_core.position
   PyFocus.auxiliary.tmm_core.position_resolved
   PyFocus.auxiliary.tmm_core.find_in_structure
   PyFocus.auxiliary.tmm_core.find_in_structure_with_inf
   PyFocus.auxiliary.tmm_core.layer_starts
   PyFocus.auxiliary.tmm_core.absorp_in_each_layer
   PyFocus.auxiliary.tmm_core.inc_group_layers
   PyFocus.auxiliary.tmm_core.inc_tmm
   PyFocus.auxiliary.tmm_core.inc_absorp_in_each_layer
   PyFocus.auxiliary.tmm_core.inc_find_absorp_analytic_fn



Attributes
~~~~~~~~~~

.. autoapisummary::

   PyFocus.auxiliary.tmm_core.EPSILON


.. data:: EPSILON
   

   

.. function:: make_2x2_array(a, b, c, d, dtype=float)

   Makes a 2x2 numpy array of [[a,b],[c,d]]

   Same as "numpy.array([[a,b],[c,d]], dtype=float)", but ten times faster


.. function:: is_forward_angle(n, theta)

   if a wave is traveling at angle theta from normal in a medium with index n,
   calculate whether or not this is the forward-traveling wave (i.e., the one
   going from front to back of the stack, like the incoming or outgoing waves,
   but unlike the reflected wave). For real n & theta, the criterion is simply
   -pi/2 < theta < pi/2, but for complex n & theta, it's more complicated.
   See https://arxiv.org/abs/1603.02720 appendix D. If theta is the forward
   angle, then (pi-theta) is the backward angle and vice-versa.


.. function:: snell(n_1, n_2, th_1)

   return angle theta in layer 2 with refractive index n_2, assuming
   it has angle th_1 in layer with refractive index n_1. Use Snell's law. Note
   that "angles" may be complex!!


.. function:: list_snell(n_list, th_0)

   return list of angle theta in each layer based on angle th_0 in layer 0,
   using Snell's law. n_list is index of refraction of each layer. Note that
   "angles" may be complex!!


.. function:: interface_r(polarization, n_i, n_f, th_i, th_f)

   reflection amplitude (from Fresnel equations)

   polarization is either "s" or "p" for polarization

   n_i, n_f are (complex) refractive index for incident and final

   th_i, th_f are (complex) propegation angle for incident and final
   (in radians, where 0=normal). "th" stands for "theta".


.. function:: interface_t(polarization, n_i, n_f, th_i, th_f)

   transmission amplitude (from Fresnel equations)

   polarization is either "s" or "p" for polarization

   n_i, n_f are (complex) refractive index for incident and final

   th_i, th_f are (complex) propegation angle for incident and final
   (in radians, where 0=normal). "th" stands for "theta".


.. function:: R_from_r(r)

   Calculate reflected power R, starting with reflection amplitude r.


.. function:: T_from_t(pol, t, n_i, n_f, th_i, th_f)

   Calculate transmitted power T, starting with transmission amplitude t.

   n_i,n_f are refractive indices of incident and final medium.

   th_i, th_f are (complex) propegation angles through incident & final medium
   (in radians, where 0=normal). "th" stands for "theta".

   In the case that n_i,n_f,th_i,th_f are real, formulas simplify to
   T=|t|^2 * (n_f cos(th_f)) / (n_i cos(th_i)).

   See manual for discussion of formulas


.. function:: power_entering_from_r(pol, r, n_i, th_i)

   Calculate the power entering the first interface of the stack, starting with
   reflection amplitude r. Normally this equals 1-R, but in the unusual case
   that n_i is not real, it can be a bit different than 1-R. See manual.

   n_i is refractive index of incident medium.

   th_i is (complex) propegation angle through incident medium
   (in radians, where 0=normal). "th" stands for "theta".


.. function:: interface_R(polarization, n_i, n_f, th_i, th_f)

   Fraction of light intensity reflected at an interface.


.. function:: interface_T(polarization, n_i, n_f, th_i, th_f)

   Fraction of light intensity transmitted at an interface.


.. function:: coh_tmm(pol, n_list, d_list, th_0, lam_vac)

   Main "coherent transfer matrix method" calc. Given parameters of a stack,
   calculates everything you could ever want to know about how light
   propagates in it. (If performance is an issue, you can delete some of the
   calculations without affecting the rest.)

   pol is light polarization, "s" or "p".

   n_list is the list of refractive indices, in the order that the light would
   pass through them. The 0'th element of the list should be the semi-infinite
   medium from which the light enters, the last element should be the semi-
   infinite medium to which the light exits (if any exits).

   th_0 is the angle of incidence: 0 for normal, pi/2 for glancing.
   Remember, for a dissipative incoming medium (n_list[0] is not real), th_0
   should be complex so that n0 sin(th0) is real (intensity is constant as
   a function of lateral position).

   d_list is the list of layer thicknesses (front to back). Should correspond
   one-to-one with elements of n_list. First and last elements should be "inf".

   lam_vac is vacuum wavelength of the light.

   Outputs the following as a dictionary (see manual for details)

   * r--reflection amplitude
   * t--transmission amplitude
   * R--reflected wave power (as fraction of incident)
   * T--transmitted wave power (as fraction of incident)
   * power_entering--Power entering the first layer, usually (but not always)
     equal to 1-R (see manual).
   * vw_list-- n'th element is [v_n,w_n], the forward- and backward-traveling
     amplitudes, respectively, in the n'th medium just after interface with
     (n-1)st medium.
   * kz_list--normal component of complex angular wavenumber for
     forward-traveling wave in each layer.
   * th_list--(complex) propagation angle (in radians) in each layer 
   * pol, n_list, d_list, th_0, lam_vac--same as input


.. function:: coh_tmm_reverse(pol, n_list, d_list, th_0, lam_vac)

   Reverses the order of the stack then runs coh_tmm.


.. function:: ellips(n_list, d_list, th_0, lam_vac)

   Calculates ellipsometric parameters, in radians.

   Warning: Conventions differ. You may need to subtract pi/2 or whatever.


.. function:: unpolarized_RT(n_list, d_list, th_0, lam_vac)

   Calculates reflected and transmitted power for unpolarized light.


.. function:: position(xyz, layer, dist, coh_tmm_data)

   Starting with output of coh_tmm(), calculate 
   a distance "dist" into layer number "layer", for x, y or z


.. function:: position_resolved(layer, dist, coh_tmm_data)

   Starting with output of coh_tmm(), calculate the Poynting vector
   and absorbed energy density a distance "dist" into layer number "layer"


.. function:: find_in_structure(d_list, dist)

   d_list is list of thicknesses of layers, all of which are finite.

   dist is the distance from the front of the whole multilayer structure
   (i.e., from the start of layer 0.)

   Function returns [layer,z], where:

   layer is what number layer you're at.
   (For large enough dist, layer = len(d_list), even though d_list[layer]
   doesn't exist in that case.

   z is the distance into that layer.


.. function:: find_in_structure_with_inf(d_list, dist)

   d_list is list of thicknesses of layers [inf, blah, blah, ..., blah, inf]

   dist is the distance from the front of the whole multilayer structure
   (i.e., frcom the start of layer 1.)

   Function returns [layer,z], where:

   layer is what number layer you're at,

   z is the distance into that layer.


.. function:: layer_starts(d_list)

   Gives the location of the start of any given layer, relative to the front
   of the whole multilayer structure. (i.e. the start of layer 1)

   d_list is list of thicknesses of layers [inf, blah, blah, ..., blah, inf]


.. class:: absorp_analytic_fn

   Absorption in a given layer is a pretty simple analytical function:
   The sum of four exponentials.

   a(z) = A1*exp(a1*z) + A2*exp(-a1*z)
          + A3*exp(1j*a3*z) + conj(A3)*exp(-1j*a3*z)

   where a(z) is absorption at depth z, with z=0 being the start of the layer,
   and A1,A2,a1,a3 are real numbers, with a1>0, a3>0, and A3 is complex.
   The class stores these five parameters, as well as d, the layer thickness.

   This gives absorption as a fraction of intensity coming towards the first
   layer of the stack.

   .. method:: fill_in(self, coh_tmm_data, layer)

      fill in the absorption analytic function starting from coh_tmm_data
      (the output of coh_tmm), for absorption in the layer with index
      "layer".


   .. method:: copy(self)

      Create copy of an absorp_analytic_fn object


   .. method:: run(self, z)

      Calculates absorption at a given depth z, where z=0 is the start of the
      layer.


   .. method:: flip(self)

      Flip the function front-to-back, to describe a(d-z) instead of a(z),
      where d is layer thickness.


   .. method:: scale(self, factor)

      multiplies the absorption at each point by "factor".


   .. method:: add(self, b)

      adds another compatible absorption analytical function



.. function:: absorp_in_each_layer(coh_tmm_data)

   An array listing what proportion of light is absorbed in each layer.

   Assumes the final layer eventually absorbs all transmitted light.

   Assumes the initial layer eventually absorbs all reflected light.

   Entries of array should sum to 1.

   coh_tmm_data is output of coh_tmm()


.. function:: inc_group_layers(n_list, d_list, c_list)

   Helper function for inc_tmm. Groups and sorts layer information.

   See coh_tmm for definitions of n_list, d_list.

   c_list is "coherency list". Each entry should be 'i' for incoherent or 'c'
   for 'coherent'.

   A "stack" is a group of one or more consecutive coherent layers. A "stack
   index" labels the stacks 0,1,2,.... The "within-stack index" counts the
   coherent layers within the stack 1,2,3... [index 0 is the incoherent layer
   before the stack starts]

   An "incoherent layer index" labels the incoherent layers 0,1,2,...

   An "alllayer index" labels all layers (all elements of d_list) 0,1,2,...

   Returns info about how the layers relate:

   * stack_d_list[i] = list of thicknesses of each coherent layer in the i'th
     stack, plus starting and ending with "inf"
   * stack_n_list[i] = list of refractive index of each coherent layer in the
     i'th stack, plus the two surrounding incoherent layers
   * all_from_inc[i] = j means that the layer with incoherent index i has
     alllayer index j
   * inc_from_all[i] = j means that the layer with alllayer index i has
     incoherent index j. If j = nan then the layer is coherent.
   * all_from_stack[i1][i2] = j means that the layer with stack index i1 and
     within-stack index i2 has alllayer index j
   * stack_from_all[i] = [j1 j2] means that the layer with alllayer index i is
     part of stack j1 with withinstack-index j2. If stack_from_all[i] = nan
     then the layer is incoherent
   * inc_from_stack[i] = j means that the i'th stack comes after the layer
     with incoherent index j, and before the layer with incoherent index j+1.
   * stack_from_inc[i] = j means that the layer with incoherent index i comes
     immediately after the j'th stack. If j=nan, it is not immediately
     following a stack.
   * num_stacks = number of stacks
   * num_inc_layers = number of incoherent layers
   * num_layers = number of layers total


.. function:: inc_tmm(pol, n_list, d_list, c_list, th_0, lam_vac)

   Incoherent, or partly-incoherent-partly-coherent, transfer matrix method.

   See coh_tmm for definitions of pol, n_list, d_list, th_0, lam_vac.

   c_list is "coherency list". Each entry should be 'i' for incoherent or 'c'
   for 'coherent'.

   If an incoherent layer has real refractive index (no absorption), then its
   thickness doesn't affect the calculation results.

   See manual for details.

   Outputs the following as a dictionary (see manual for details):

   * R--reflected wave power (as fraction of incident)
   * T--transmitted wave power (as fraction of incident)
   * VW_list-- n'th element is [V_n,W_n], the forward- and backward-traveling
     intensities, respectively, at the beginning of the n'th incoherent medium.
   * coh_tmm_data_list--n'th element is coh_tmm_data[n], the output of
     the coh_tmm program for the n'th "stack" (group of one or more
     consecutive coherent layers).
   * coh_tmm_bdata_list--n'th element is coh_tmm_bdata[n], the output of the
     coh_tmm program for the n'th stack, but with the layers of the stack
     in reverse order.
   * stackFB_list--n'th element is [F,B], where F is light traveling forward
     towards the n'th stack and B is light traveling backwards towards the n'th
     stack.
   * num_layers-- total number both coherent and incoherent.
   * power_entering_list--n'th element is the normalized Poynting vector
     crossing the interface into the n'th incoherent layer from the previous
     (coherent or incoherent) layer.
   * Plus, all the outputs of inc_group_layers


.. function:: inc_absorp_in_each_layer(inc_data)

   A list saying what proportion of light is absorbed in each layer.

   Assumes all reflected light is eventually absorbed in the 0'th medium, and
   all transmitted light is eventually absorbed in the final medium.

   Returns a list [layer0absorp, layer1absorp, ...]. Entries should sum to 1.

   inc_data is output of incoherent_main()


.. function:: inc_find_absorp_analytic_fn(layer, inc_data)

   Outputs an absorp_analytic_fn object for a coherent layer within a
   partly-incoherent stack.

   inc_data is output of incoherent_main()


