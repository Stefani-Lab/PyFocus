

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyFocus.auxiliary.tmm_core &mdash; Test  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> Test
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">PyFocus documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-user_interface">User interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-sim">High-level simulation functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-auxiliary.VPP_functions">Internal functions for VPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-auxiliary.no_mask_functions">Internal functions for no mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-auxiliary.custom_mask_functions">Internal functions for a custom mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html#module-auxiliary.interface">Internal functions for an interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Test</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">PyFocus.auxiliary.tmm_core</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/autoapi/PyFocus/auxiliary/tmm_core/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-PyFocus.auxiliary.tmm_core">
<span id="pyfocus-auxiliary-tmm-core"></span><h1><a class="reference internal" href="#module-PyFocus.auxiliary.tmm_core" title="PyFocus.auxiliary.tmm_core"><code class="xref py py-mod docutils literal notranslate"><span class="pre">PyFocus.auxiliary.tmm_core</span></code></a><a class="headerlink" href="#module-PyFocus.auxiliary.tmm_core" title="Permalink to this headline">¶</a></h1>
<p>For information see the docstring of each function, and also see manual.pdf</p>
<p>The most two important functions are:</p>
<p>coh_tmm(…) – the transfer-matrix-method calculation in the coherent
case (i.e. thin films)</p>
<p>inc_tmm(…) – the transfer-matrix-method calculation in the incoherent
case (i.e. films tens or hundreds of wavelengths thick, or whose
thickness is not very uniform.)</p>
<p>These functions are all imported into the main package (tmm) namespace,
so you can call them with tmm.coh_tmm(…) etc.</p>
<div class="section" id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn" title="PyFocus.auxiliary.tmm_core.absorp_analytic_fn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">absorp_analytic_fn</span></code></a></p></td>
<td><p>Absorption in a given layer is a pretty simple analytical function:</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.make_2x2_array" title="PyFocus.auxiliary.tmm_core.make_2x2_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_2x2_array</span></code></a>(a, b, c, d, dtype=float)</p></td>
<td><p>Makes a 2x2 numpy array of [[a,b],[c,d]]</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.is_forward_angle" title="PyFocus.auxiliary.tmm_core.is_forward_angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_forward_angle</span></code></a>(n, theta)</p></td>
<td><p>if a wave is traveling at angle theta from normal in a medium with index n,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.snell" title="PyFocus.auxiliary.tmm_core.snell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">snell</span></code></a>(n_1, n_2, th_1)</p></td>
<td><p>return angle theta in layer 2 with refractive index n_2, assuming</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.list_snell" title="PyFocus.auxiliary.tmm_core.list_snell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list_snell</span></code></a>(n_list, th_0)</p></td>
<td><p>return list of angle theta in each layer based on angle th_0 in layer 0,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.interface_r" title="PyFocus.auxiliary.tmm_core.interface_r"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interface_r</span></code></a>(polarization, n_i, n_f, th_i, th_f)</p></td>
<td><p>reflection amplitude (from Fresnel equations)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.interface_t" title="PyFocus.auxiliary.tmm_core.interface_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interface_t</span></code></a>(polarization, n_i, n_f, th_i, th_f)</p></td>
<td><p>transmission amplitude (from Fresnel equations)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.R_from_r" title="PyFocus.auxiliary.tmm_core.R_from_r"><code class="xref py py-obj docutils literal notranslate"><span class="pre">R_from_r</span></code></a>(r)</p></td>
<td><p>Calculate reflected power R, starting with reflection amplitude r.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.T_from_t" title="PyFocus.auxiliary.tmm_core.T_from_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_from_t</span></code></a>(pol, t, n_i, n_f, th_i, th_f)</p></td>
<td><p>Calculate transmitted power T, starting with transmission amplitude t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.power_entering_from_r" title="PyFocus.auxiliary.tmm_core.power_entering_from_r"><code class="xref py py-obj docutils literal notranslate"><span class="pre">power_entering_from_r</span></code></a>(pol, r, n_i, th_i)</p></td>
<td><p>Calculate the power entering the first interface of the stack, starting with</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.interface_R" title="PyFocus.auxiliary.tmm_core.interface_R"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interface_R</span></code></a>(polarization, n_i, n_f, th_i, th_f)</p></td>
<td><p>Fraction of light intensity reflected at an interface.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.interface_T" title="PyFocus.auxiliary.tmm_core.interface_T"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interface_T</span></code></a>(polarization, n_i, n_f, th_i, th_f)</p></td>
<td><p>Fraction of light intensity transmitted at an interface.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.coh_tmm" title="PyFocus.auxiliary.tmm_core.coh_tmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coh_tmm</span></code></a>(pol, n_list, d_list, th_0, lam_vac)</p></td>
<td><p>Main “coherent transfer matrix method” calc. Given parameters of a stack,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.coh_tmm_reverse" title="PyFocus.auxiliary.tmm_core.coh_tmm_reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coh_tmm_reverse</span></code></a>(pol, n_list, d_list, th_0, lam_vac)</p></td>
<td><p>Reverses the order of the stack then runs coh_tmm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.ellips" title="PyFocus.auxiliary.tmm_core.ellips"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellips</span></code></a>(n_list, d_list, th_0, lam_vac)</p></td>
<td><p>Calculates ellipsometric parameters, in radians.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.unpolarized_RT" title="PyFocus.auxiliary.tmm_core.unpolarized_RT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unpolarized_RT</span></code></a>(n_list, d_list, th_0, lam_vac)</p></td>
<td><p>Calculates reflected and transmitted power for unpolarized light.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.position" title="PyFocus.auxiliary.tmm_core.position"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code></a>(xyz, layer, dist, coh_tmm_data)</p></td>
<td><p>Starting with output of coh_tmm(), calculate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.position_resolved" title="PyFocus.auxiliary.tmm_core.position_resolved"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_resolved</span></code></a>(layer, dist, coh_tmm_data)</p></td>
<td><p>Starting with output of coh_tmm(), calculate the Poynting vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.find_in_structure" title="PyFocus.auxiliary.tmm_core.find_in_structure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_in_structure</span></code></a>(d_list, dist)</p></td>
<td><p>d_list is list of thicknesses of layers, all of which are finite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.find_in_structure_with_inf" title="PyFocus.auxiliary.tmm_core.find_in_structure_with_inf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_in_structure_with_inf</span></code></a>(d_list, dist)</p></td>
<td><p>d_list is list of thicknesses of layers [inf, blah, blah, …, blah, inf]</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.layer_starts" title="PyFocus.auxiliary.tmm_core.layer_starts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">layer_starts</span></code></a>(d_list)</p></td>
<td><p>Gives the location of the start of any given layer, relative to the front</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.absorp_in_each_layer" title="PyFocus.auxiliary.tmm_core.absorp_in_each_layer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">absorp_in_each_layer</span></code></a>(coh_tmm_data)</p></td>
<td><p>An array listing what proportion of light is absorbed in each layer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.inc_group_layers" title="PyFocus.auxiliary.tmm_core.inc_group_layers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inc_group_layers</span></code></a>(n_list, d_list, c_list)</p></td>
<td><p>Helper function for inc_tmm. Groups and sorts layer information.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.inc_tmm" title="PyFocus.auxiliary.tmm_core.inc_tmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inc_tmm</span></code></a>(pol, n_list, d_list, c_list, th_0, lam_vac)</p></td>
<td><p>Incoherent, or partly-incoherent-partly-coherent, transfer matrix method.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.inc_absorp_in_each_layer" title="PyFocus.auxiliary.tmm_core.inc_absorp_in_each_layer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inc_absorp_in_each_layer</span></code></a>(inc_data)</p></td>
<td><p>A list saying what proportion of light is absorbed in each layer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.inc_find_absorp_analytic_fn" title="PyFocus.auxiliary.tmm_core.inc_find_absorp_analytic_fn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inc_find_absorp_analytic_fn</span></code></a>(layer, inc_data)</p></td>
<td><p>Outputs an absorp_analytic_fn object for a coherent layer within a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#PyFocus.auxiliary.tmm_core.EPSILON" title="PyFocus.auxiliary.tmm_core.EPSILON"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EPSILON</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.EPSILON">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">EPSILON</span></span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.EPSILON" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.make_2x2_array">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">make_2x2_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.make_2x2_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a 2x2 numpy array of [[a,b],[c,d]]</p>
<p>Same as “numpy.array([[a,b],[c,d]], dtype=float)”, but ten times faster</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.is_forward_angle">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">is_forward_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.is_forward_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>if a wave is traveling at angle theta from normal in a medium with index n,
calculate whether or not this is the forward-traveling wave (i.e., the one
going from front to back of the stack, like the incoming or outgoing waves,
but unlike the reflected wave). For real n &amp; theta, the criterion is simply
-pi/2 &lt; theta &lt; pi/2, but for complex n &amp; theta, it’s more complicated.
See <a class="reference external" href="https://arxiv.org/abs/1603.02720">https://arxiv.org/abs/1603.02720</a> appendix D. If theta is the forward
angle, then (pi-theta) is the backward angle and vice-versa.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.snell">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">snell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.snell" title="Permalink to this definition">¶</a></dt>
<dd><p>return angle theta in layer 2 with refractive index n_2, assuming
it has angle th_1 in layer with refractive index n_1. Use Snell’s law. Note
that “angles” may be complex!!</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.list_snell">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">list_snell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.list_snell" title="Permalink to this definition">¶</a></dt>
<dd><p>return list of angle theta in each layer based on angle th_0 in layer 0,
using Snell’s law. n_list is index of refraction of each layer. Note that
“angles” may be complex!!</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.interface_r">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">interface_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.interface_r" title="Permalink to this definition">¶</a></dt>
<dd><p>reflection amplitude (from Fresnel equations)</p>
<p>polarization is either “s” or “p” for polarization</p>
<p>n_i, n_f are (complex) refractive index for incident and final</p>
<p>th_i, th_f are (complex) propegation angle for incident and final
(in radians, where 0=normal). “th” stands for “theta”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.interface_t">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">interface_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.interface_t" title="Permalink to this definition">¶</a></dt>
<dd><p>transmission amplitude (from Fresnel equations)</p>
<p>polarization is either “s” or “p” for polarization</p>
<p>n_i, n_f are (complex) refractive index for incident and final</p>
<p>th_i, th_f are (complex) propegation angle for incident and final
(in radians, where 0=normal). “th” stands for “theta”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.R_from_r">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">R_from_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.R_from_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate reflected power R, starting with reflection amplitude r.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.T_from_t">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">T_from_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.T_from_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate transmitted power T, starting with transmission amplitude t.</p>
<p>n_i,n_f are refractive indices of incident and final medium.</p>
<p>th_i, th_f are (complex) propegation angles through incident &amp; final medium
(in radians, where 0=normal). “th” stands for “theta”.</p>
<p>In the case that n_i,n_f,th_i,th_f are real, formulas simplify to
T=|t|^2 * (n_f cos(th_f)) / (n_i cos(th_i)).</p>
<p>See manual for discussion of formulas</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.power_entering_from_r">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">power_entering_from_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.power_entering_from_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power entering the first interface of the stack, starting with
reflection amplitude r. Normally this equals 1-R, but in the unusual case
that n_i is not real, it can be a bit different than 1-R. See manual.</p>
<p>n_i is refractive index of incident medium.</p>
<p>th_i is (complex) propegation angle through incident medium
(in radians, where 0=normal). “th” stands for “theta”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.interface_R">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">interface_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.interface_R" title="Permalink to this definition">¶</a></dt>
<dd><p>Fraction of light intensity reflected at an interface.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.interface_T">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">interface_T</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.interface_T" title="Permalink to this definition">¶</a></dt>
<dd><p>Fraction of light intensity transmitted at an interface.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.coh_tmm">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">coh_tmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_vac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.coh_tmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Main “coherent transfer matrix method” calc. Given parameters of a stack,
calculates everything you could ever want to know about how light
propagates in it. (If performance is an issue, you can delete some of the
calculations without affecting the rest.)</p>
<p>pol is light polarization, “s” or “p”.</p>
<p>n_list is the list of refractive indices, in the order that the light would
pass through them. The 0’th element of the list should be the semi-infinite
medium from which the light enters, the last element should be the semi-
infinite medium to which the light exits (if any exits).</p>
<p>th_0 is the angle of incidence: 0 for normal, pi/2 for glancing.
Remember, for a dissipative incoming medium (n_list[0] is not real), th_0
should be complex so that n0 sin(th0) is real (intensity is constant as
a function of lateral position).</p>
<p>d_list is the list of layer thicknesses (front to back). Should correspond
one-to-one with elements of n_list. First and last elements should be “inf”.</p>
<p>lam_vac is vacuum wavelength of the light.</p>
<p>Outputs the following as a dictionary (see manual for details)</p>
<ul class="simple">
<li><p>r–reflection amplitude</p></li>
<li><p>t–transmission amplitude</p></li>
<li><p>R–reflected wave power (as fraction of incident)</p></li>
<li><p>T–transmitted wave power (as fraction of incident)</p></li>
<li><p>power_entering–Power entering the first layer, usually (but not always)
equal to 1-R (see manual).</p></li>
<li><p>vw_list– n’th element is [v_n,w_n], the forward- and backward-traveling
amplitudes, respectively, in the n’th medium just after interface with
(n-1)st medium.</p></li>
<li><p>kz_list–normal component of complex angular wavenumber for
forward-traveling wave in each layer.</p></li>
<li><p>th_list–(complex) propagation angle (in radians) in each layer</p></li>
<li><p>pol, n_list, d_list, th_0, lam_vac–same as input</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.coh_tmm_reverse">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">coh_tmm_reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_vac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.coh_tmm_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the order of the stack then runs coh_tmm.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.ellips">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">ellips</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_vac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.ellips" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates ellipsometric parameters, in radians.</p>
<p>Warning: Conventions differ. You may need to subtract pi/2 or whatever.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.unpolarized_RT">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">unpolarized_RT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_vac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.unpolarized_RT" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates reflected and transmitted power for unpolarized light.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.position">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">position</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coh_tmm_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Starting with output of coh_tmm(), calculate
a distance “dist” into layer number “layer”, for x, y or z</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.position_resolved">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">position_resolved</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coh_tmm_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.position_resolved" title="Permalink to this definition">¶</a></dt>
<dd><p>Starting with output of coh_tmm(), calculate the Poynting vector
and absorbed energy density a distance “dist” into layer number “layer”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.find_in_structure">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">find_in_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.find_in_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>d_list is list of thicknesses of layers, all of which are finite.</p>
<p>dist is the distance from the front of the whole multilayer structure
(i.e., from the start of layer 0.)</p>
<p>Function returns [layer,z], where:</p>
<p>layer is what number layer you’re at.
(For large enough dist, layer = len(d_list), even though d_list[layer]
doesn’t exist in that case.</p>
<p>z is the distance into that layer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.find_in_structure_with_inf">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">find_in_structure_with_inf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.find_in_structure_with_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>d_list is list of thicknesses of layers [inf, blah, blah, …, blah, inf]</p>
<p>dist is the distance from the front of the whole multilayer structure
(i.e., frcom the start of layer 1.)</p>
<p>Function returns [layer,z], where:</p>
<p>layer is what number layer you’re at,</p>
<p>z is the distance into that layer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.layer_starts">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">layer_starts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.layer_starts" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the location of the start of any given layer, relative to the front
of the whole multilayer structure. (i.e. the start of layer 1)</p>
<p>d_list is list of thicknesses of layers [inf, blah, blah, …, blah, inf]</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">absorp_analytic_fn</span></span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorption in a given layer is a pretty simple analytical function:
The sum of four exponentials.</p>
<dl class="simple">
<dt>a(z) = A1*exp(a1*z) + A2*exp(-a1*z)</dt><dd><ul class="simple">
<li><p>A3*exp(1j*a3*z) + conj(A3)*exp(-1j*a3*z)</p></li>
</ul>
</dd>
</dl>
<p>where a(z) is absorption at depth z, with z=0 being the start of the layer,
and A1,A2,a1,a3 are real numbers, with a1&gt;0, a3&gt;0, and A3 is complex.
The class stores these five parameters, as well as d, the layer thickness.</p>
<p>This gives absorption as a fraction of intensity coming towards the first
layer of the stack.</p>
<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.fill_in">
<span class="sig-name descname"><span class="pre">fill_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coh_tmm_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.fill_in" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in the absorption analytic function starting from coh_tmm_data
(the output of coh_tmm), for absorption in the layer with index
“layer”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create copy of an absorp_analytic_fn object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates absorption at a given depth z, where z=0 is the start of the
layer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.flip">
<span class="sig-name descname"><span class="pre">flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip the function front-to-back, to describe a(d-z) instead of a(z),
where d is layer thickness.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>multiplies the absorption at each point by “factor”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_analytic_fn.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_analytic_fn.add" title="Permalink to this definition">¶</a></dt>
<dd><p>adds another compatible absorption analytical function</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.absorp_in_each_layer">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">absorp_in_each_layer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coh_tmm_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.absorp_in_each_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>An array listing what proportion of light is absorbed in each layer.</p>
<p>Assumes the final layer eventually absorbs all transmitted light.</p>
<p>Assumes the initial layer eventually absorbs all reflected light.</p>
<p>Entries of array should sum to 1.</p>
<p>coh_tmm_data is output of coh_tmm()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.inc_group_layers">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">inc_group_layers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.inc_group_layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for inc_tmm. Groups and sorts layer information.</p>
<p>See coh_tmm for definitions of n_list, d_list.</p>
<p>c_list is “coherency list”. Each entry should be ‘i’ for incoherent or ‘c’
for ‘coherent’.</p>
<p>A “stack” is a group of one or more consecutive coherent layers. A “stack
index” labels the stacks 0,1,2,…. The “within-stack index” counts the
coherent layers within the stack 1,2,3… [index 0 is the incoherent layer
before the stack starts]</p>
<p>An “incoherent layer index” labels the incoherent layers 0,1,2,…</p>
<p>An “alllayer index” labels all layers (all elements of d_list) 0,1,2,…</p>
<p>Returns info about how the layers relate:</p>
<ul class="simple">
<li><p>stack_d_list[i] = list of thicknesses of each coherent layer in the i’th
stack, plus starting and ending with “inf”</p></li>
<li><p>stack_n_list[i] = list of refractive index of each coherent layer in the
i’th stack, plus the two surrounding incoherent layers</p></li>
<li><p>all_from_inc[i] = j means that the layer with incoherent index i has
alllayer index j</p></li>
<li><p>inc_from_all[i] = j means that the layer with alllayer index i has
incoherent index j. If j = nan then the layer is coherent.</p></li>
<li><p>all_from_stack[i1][i2] = j means that the layer with stack index i1 and
within-stack index i2 has alllayer index j</p></li>
<li><p>stack_from_all[i] = [j1 j2] means that the layer with alllayer index i is
part of stack j1 with withinstack-index j2. If stack_from_all[i] = nan
then the layer is incoherent</p></li>
<li><p>inc_from_stack[i] = j means that the i’th stack comes after the layer
with incoherent index j, and before the layer with incoherent index j+1.</p></li>
<li><p>stack_from_inc[i] = j means that the layer with incoherent index i comes
immediately after the j’th stack. If j=nan, it is not immediately
following a stack.</p></li>
<li><p>num_stacks = number of stacks</p></li>
<li><p>num_inc_layers = number of incoherent layers</p></li>
<li><p>num_layers = number of layers total</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.inc_tmm">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">inc_tmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">th_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam_vac</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.inc_tmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Incoherent, or partly-incoherent-partly-coherent, transfer matrix method.</p>
<p>See coh_tmm for definitions of pol, n_list, d_list, th_0, lam_vac.</p>
<p>c_list is “coherency list”. Each entry should be ‘i’ for incoherent or ‘c’
for ‘coherent’.</p>
<p>If an incoherent layer has real refractive index (no absorption), then its
thickness doesn’t affect the calculation results.</p>
<p>See manual for details.</p>
<p>Outputs the following as a dictionary (see manual for details):</p>
<ul class="simple">
<li><p>R–reflected wave power (as fraction of incident)</p></li>
<li><p>T–transmitted wave power (as fraction of incident)</p></li>
<li><p>VW_list– n’th element is [V_n,W_n], the forward- and backward-traveling
intensities, respectively, at the beginning of the n’th incoherent medium.</p></li>
<li><p>coh_tmm_data_list–n’th element is coh_tmm_data[n], the output of
the coh_tmm program for the n’th “stack” (group of one or more
consecutive coherent layers).</p></li>
<li><p>coh_tmm_bdata_list–n’th element is coh_tmm_bdata[n], the output of the
coh_tmm program for the n’th stack, but with the layers of the stack
in reverse order.</p></li>
<li><p>stackFB_list–n’th element is [F,B], where F is light traveling forward
towards the n’th stack and B is light traveling backwards towards the n’th
stack.</p></li>
<li><p>num_layers– total number both coherent and incoherent.</p></li>
<li><p>power_entering_list–n’th element is the normalized Poynting vector
crossing the interface into the n’th incoherent layer from the previous
(coherent or incoherent) layer.</p></li>
<li><p>Plus, all the outputs of inc_group_layers</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.inc_absorp_in_each_layer">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">inc_absorp_in_each_layer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inc_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.inc_absorp_in_each_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>A list saying what proportion of light is absorbed in each layer.</p>
<p>Assumes all reflected light is eventually absorbed in the 0’th medium, and
all transmitted light is eventually absorbed in the final medium.</p>
<p>Returns a list [layer0absorp, layer1absorp, …]. Entries should sum to 1.</p>
<p>inc_data is output of incoherent_main()</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyFocus.auxiliary.tmm_core.inc_find_absorp_analytic_fn">
<span class="sig-prename descclassname"><span class="pre">PyFocus.auxiliary.tmm_core.</span></span><span class="sig-name descname"><span class="pre">inc_find_absorp_analytic_fn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inc_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#PyFocus.auxiliary.tmm_core.inc_find_absorp_analytic_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs an absorp_analytic_fn object for a coherent layer within a
partly-incoherent stack.</p>
<p>inc_data is output of incoherent_main()</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, FC

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>